第1课
1.1，起航，新的目标
    数据结构课程的意义
        培养专业的程序设计思维
        训练使用程序语言描述解决方案的能力
        计算机专业的基础课程
        算法分析专业课的先修课程

    课程目标
        创建可复用的数据结构软件库
        分析并优化C++课程中创建的实用类
    使用的技术
        C++面向对象技术
        C++模板技术
        C++异常处理技术

1.2，理解程序的本质
    程序评鉴初探
        用尽量少的时间解决问题
        用尽量少的步骤解决问题
        用尽量少的内存解决问题
    优秀的开发者追求高质量的代码

    数据结构课程的研究范围
        非数值计算类型的程序问题
        数据间的组织和操作方式
        数据的逻辑结构和存储结构

第1课小结
    程序是为了解决实际问题而存在的
    针对同一个问题可以有多种解决方案
    专业程序员应该尽量追求高质量的程序
    数据结构课程主要研究非数值计算问题

第2课
2.1，数据的艺术
    数据的概念
        程序的操作对象，用于描述客观事物
    数据的特点
        可以输入到计算机
        可以被计算机程序处理
    数据的新概念
        数据元素
            组成数据的基本单位
        数据项
            一个数据元素由若干数据项组成
        数据对象
            性质相同的数据元素的集合

    数据结构指数据对象中数据元素之间的关系
        数据元素之间不是独立的
            存在特定的关系，这些关系即结构
        如：
            数据中各个元素之间存在固定的线性关系

    逻辑结构包括：
        集合结构
            数据元素之间没有特别的关系，仅同属相同集合
        线性结构
            数据元素之间是一对一的关系
        树形结构
            数据元素之间存在一对多的层次关系
        图形结构
            数据元素之间是多对多的关系

    物理结构：
        逻辑结构在计算机中的存储形式
            顺序存储结构
                将数据存储在地址连续的存储单元里
            链式存储结构
                将数据存储在任意的存储单元里
                通过保存地址的方式找到相关联的数据元素

第2课小结
    数据结构是相互之间存在特定关系的数据元素的集合
    数据结构可以分为逻辑结构和物理结构

第3课
3.1， 初识程序的灵魂
    数据结构静态的描述了数据元素之间的关系
    高效的程序需要子啊数据结构的技术上设计和选择算法
                        恰当的数据结构
        搞笑的程序-->
                        合适的算法
    
    算法是特定问题求解步骤的描述
    在计算机中表现为指令的有限序列
        算法是独立存在的一种解决问题的方法和思想
        对于算法而言，语言并不重要，重要的是思想

    算法的特性
        输入：算法具有0个或多个输入
        输出：算法至少有1个或多个输出
        有穷性：算法在有限的步骤之后会自动结束而不会无限循环
        确定型：算法中的每一步都有确定的含义，不会出现二义性
        可行性：算法的每一步都是可行的
        正确性：算法对于合法数据能够得到满足要求的结果
                算法能够处理非法输入，并得到合理的结果
                算法对于边界数据和压力数据都得到满足要求的结果
                注意：正确性时算法最需要满足的基本的准则，但是作为
                      计算机程序，不可能无限制的满足这条准则。
        可读性：算法要方便阅读，理解和交流
        健壮性：算法不应该产莫明奇妙的结果
        性价比：利用最少的资源得到满足要求的结果

第3课小结
    算法为了解决实际问题而存在
    数据结构是算法处理问题的载体
    数据结构与算法相辅相成，共同解决问题

第4课
4.1，程序灵魂的审判
    如果两个算法都满足功能性需求，工程中最关心的其他特性是是什么？如何比较评判呢？
    注意：
        性价比(效率)是工程中最关注的算法附加特性！！！
    事后统计法
        比较两个不同算法对同一组数据的运行处理时间
        缺陷
            为了获得不同算法的运行时间必须编写相应程序
            运行时间严重依赖硬件以及运行时的环境因素
            算法的测试数据的选取相当困难
    事前分析估算
        依据统计的方法对算法效率进行估算
        影响算法效率的主要因素
            算法采用的策略和方法
            问题的输入规模
            编译器所产生的代码
            计算机执行速度

    判断一个算法效率时，操作数量中的常数项和其它次要项常常可以
    忽略，只需要关注最高阶项就能得出结论

第4课小结
    算法的度量有事后统计法和事前分析估算法
    事后统计法不容易准确度量算法的效率
    事前分析估算法通过操作数量度量算法效率
    判断一个算法效率时，只需要关注最高阶项就能得出结论

第5课
5.1，算法的时间复杂度
    算法的复杂度
        时间复杂度
            算法运行后对时间需求量的定性描述
        空间复杂度
            算法运行后付空间需求量的定性描述
    注意：
        数据结构课程重点关注的是算法的效率问题，因此，整个课程会集中于讨论算法的时间复杂度；
        但其使用的方法完全可以用于空间复杂度的判断！

    大O表示法
        算法效率严重依赖于操作(Operator)数量
        操作数量的估算可以作为时间复杂度的估算
        在判断时首先关注操作数量的最高次项
            O(5) = O(1)
            O(2n+1) = O(2n) = O(n)

    常见时间复杂度
        1，线性阶时间复杂度：O(n)
        for(int i = 0; i < n; i++)
        {
            // 复杂度为O(1)的程序语句
        }
        循环次数：n

        2，对数阶时间复杂度：O(logn)
        int i = 1;
        while(i < n)
        {
            // 复杂度为O(1)的程序语句
            i *= 2;
        }
        循环次数：log(小2)n

        3，平方阶时间复杂度：O(n*n)
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                // 复杂度为O(1)的程序语句
            }
        }
        循环次数：n*n

第5课小结
    时间复杂度是算法运行时对于时间的需求量
    大O表示法用于描述算法的时间复杂度
    大O表示法只关注操作数量的最高次项
    常见的时间复杂度为：线性阶，平方阶和对数阶

第6课
6.1，算法效率的度量
    常见时间复杂度的比较
        O(1) < O(logn) < O(n*logn) < O(n*n)
              < O(n*n*n)
                 <O(2的n次方) < O(n!) < O(n的n次方)
    当算法的时间复杂度为最后三种时，即使n的值很小，
    实际的程序运行时间也是不可接受的。
    实际使用的算法时间复杂度应该在第一行中。

    算法的最好情况与最坏情况
    意义：
        当算法在最坏情况下仍然能满足需求时，可以推断，
        算法的最好情况和平均情况都满足需求。

    算法的空间复杂度
    定义：S(n) = S(f(n))
        n为算法的问题规模
        f(n)为空间使用函数，与n相关
    推导时间复杂度的方法同样适用于空间复杂度
    
    空间与时间的策略
        多数情况下，算法的时间复杂度更令人关注
        如果有必要，可以通过增加额外空间降低时间复杂度
        同理，也可以通过增加算法的耗时降低空间复杂度

第6课小结
    一般而言，工程中使用的算法，时间复杂度不超过O(n*n*n)
    算法分析与设计时，重点考虑最坏情况下的时间复杂度
    数据结构课程中重点关注算法的时间复杂度
    大O表示法同样适用于算法的空间复杂度
    空间换时间是工程开发中常用的策略

第7课
7.1，课程答疑
    数据结构课程该如何学习？
        1，先从概念上形象的理解数据元素之间的关系
        2，思考这种关系能够解决什么问题
        3，考虑基于这种关系能够产生那些算法
        4，理解和熟悉最终的算法
        5，选择一种熟悉的语言，编码实战

    学习操作系统内核需要用到数据结构吗？
        内存管理
            需要设计页映射表相关的数据结构和访问算法
        进程管理
            需要设计表示进程的数据结构(PCB)和资源分配算法
        线程管理
            需要设计表示线程的数据结构(TCB)和调度算法
        。。。

第8课
8.1，泛型编程简介
    数据结构课程的特点
        专注于数据元素之间的关系
        专注与特定结构之上的算法
    数据结构课程并不关注数据元素的具体类型！

    泛型编程的概念
        不考虑具体数据类型的编程方式

    C++中的函数模板
        一种特殊的函数可用不同类型进行调用
        看起来和普通函数很相似，区别是类型可被参数化

    C++中的类模板
        以相同的方式处理不同的类型
        在类声明前使用template进行标识
        < typename T >用于说明类中使用的泛指类型T
    类模板的应用
        只能显示指定具体类型，无法自动推导
        使用具体类型<Type>定义对象

第8课小结
    模板是泛型编程理论在C++中的实现
    函数模板支持参数的自动推导和显示指定
    类模板在使用时只能显示指定类型
    类模板非常适用于编写数据结构相关的代码

第9课
9.1，智能指针示例
    内存泄露
        动态申请堆空间，用完后不归还
        C++语言中没有垃圾回收机制
        指针无法控制所指堆空间的生命周期
    当代C++软件平台中的智能指针
        指针生命周期结束时主动释放堆空间
        一片堆空间最多只能由一个指针标识
        杜绝指针运算和指针比较
    智能指针的设计方案
        通过类模板描述指针的行为
            能够定义不同类型的指针对象
        重载指针特征操作符(-> 和 *)
            利用对象模拟原生指针的行为

    智能指针的使用军规
        只能用来指向堆空间中的单个对象或者变量

第9课小结
    指针特征操作符(-> 和 *)可以被重载
    重载指针特征操作符能够使用对象代替指针
    智能指针只能用于指向堆空间中的内存
    智能指针的意义在于最大程度的避免内存泄漏问题

第10课
10.1，C++异常简介
    参考C++课程异常讲解

第11课
11.1，异常类构建
    异常的类型可以是自定义类类型
    对于类类型异常的匹配依旧是至上而下严格匹配
    赋值兼容性原则在异常匹配中依然适用
    一般而言
        匹配子类异常的catch放在上部
        匹配父类异常的catch放在下部

    现代C++库必然包含充要的异常类族
    异常类族是数据结构类所依赖的基础设施
    Exception主要包括
        ArithmeticException         计算异常
        IndexOutOfBoundsException   越界异常
        NoEnoughMemoryException     内存不足异常
        NullPointerException        空指针异常
        InvalidParameterException   参数错误异常

    设计原则
        在可复用代码库设计时，尽量使用面向对象技术进行架构，尽量使用异常处理机制
        分离正常逻辑和异常逻辑。

第11课小结
    现代C++库必然包含充要的异常类族
    所有库中的数据结构类都依赖于异常机制
    异常机制能够分离库中代码的正常逻辑和异常逻辑

第12课
12.1，顶层父类创建
    当代软件架构实践中的经验
        尽量使用单重继承的方式进行系统设计
        尽量保持系统中只存在单一的继承树
        尽量使用组合关系代替继承关系

    不幸的事实
        C++语言的灵活性使得代码中可以存在多个继承树
        C++编译器的差异使得同样的代码可能表现不同的行为

    创建DTLib::Object类的意义
        遵循经典设计准则，所有数据结构都继承自Object类
        定义动态内存申请的行为，提高代码的移植性

第12课小结
    Object类是DTLib中数据结构类的顶层父类
    Object类用于统一动态内存申请的行为
    在堆中创建Object子类的对象，失败时返回NULL值
    Object类为纯虚父类，所有子类都能进行动态类型识别

第13课
13.1，类族结构的进化
    遵循经典设计准则
        DTLib中的所有类位于单一的继承树

    改进的关键点
        Exception类继承自Object类
            堆空间中创建异常对象失败时，返回NULL指针
        新增InvalidOperatorException异常类
            成员函数调用时，如果状态不正确则抛出异常
        SmartPointer类继承自Object类
            堆空间中创建智能指针对象失败时，返回NULL指针

    DTLib的开发方式和注意事项
        迭代开发
            每次完成一个小的目标，持续开发，最终打造可复用类库
        单一继承树
            所有类都继承自Object，规范堆对象创建时的行为
        只抛异常，不处理异常
            使用THROW_EXCEPTION抛出异常，提高可移植性
        弱耦合性
            尽量不使用标准库中的类和函数，提高可移植性

第一阶段学习总结
	数据结构与算法之间的关系
	算法效率的度量方法
	DTLib的基础设施建设
		顶层父类
		智能指针
		异常类

第14课
14.1，线性表的本质和操作
	线性表(List)的表现形式
		零个或者多个数据元素组成的集合
		数据元素在位置上是有序排列的
		数据元素的个数是有限的
		数据元素的类型必须相同

	线性表的抽象定义
		线性表是具有相同类型的n(>=0)个数据元素的有限序列

	线性表(List)的性质
		a0为线性表的第一个元素，只有一个后继
		an-1 为线性表的最后一个元素，只有一个前驱
		除a0和an-1外的其他元素ai，既有前驱，又有后继
		直接支持逐项访问和顺序存取

	线性表的一些常用操作
		将元素插入线性表
		将元素从线性表中删除
		获取目标位置处元素的值
		设置目标位置处的元素的值
		获取线性表的长度
		清空线性表

第14课小结
	线性表是数据元素的有序并且有限的集合
	线性表中的数据元素必须是类型相同的
	线性表可用于描述排队关系的问题
	线性表在程序中表现为一种特殊的数据类型
	线性表在C++中表现为一个抽象类

第15课
15.1，线性表的顺序存储结构
	顺序存储的定义
		线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储
		线性表中的数据元素

	顺序存储结构的元素插入操作
		判断目标位置是否合法
		将目标位置之后的所有元素后移一个位置
		将新元素插入目标位置
		线性表长度加1

	顺序存储结构的元素删除操作
		判断目标位置是否合法
		将目标位置的所有元素前移一个位置
		线性表长度减1

第16课
16.1，顺序存储结构的抽象实现
	SeqList设计要点
		抽象类模板，存储空间的位置和大小由子类完成
		实现顺序存储结构线性表的关键操作(增，删，查，等)
		提供数组操作符，方便快速获取元素

第17课
17.1，StaticList和DynamicList
	StaticList设计要点
		类模板
			使用原生数组作为顺序存储空间
			使用模板参数决定数组大小

	DynamicList设计要点
		类模板
			申请连续堆空间作为顺序存储空间
			动态设置顺序存储空间的大小
			保证重置顺序存储空间时的异常安全性
		函数异常安全的概念
			不泄露任何资源
			不允许破坏数据
		函数异常安全的基本保证
			如果异常被抛出
				对象内的任何成员仍然保持有效状态
				没有数据的破坏及资源泄露

第17课小结
	StaticList通过模板参数定义顺序存储空间
	DynamicList通过内存申请定义顺序存储空间
	DynamicList支持动态重置顺序存储空间大小
	DynamicList中的resize()函数实现保证异常安全

第18课
18.1，顺序存储线性表的分析
	分析
		对于容器类型的类，可以考虑禁用拷贝构造和赋值操作
		template < typename T >
		class List : public Object
		{
		protected:
			List(const List&);
			List& operator=(const List&);
		public:
			List() {}
			// ...
		};

	问题分析
		顺序存储结构线性表提供了数组操作符重载，通过重载能够快捷方便的获取目标位置处的数据元素，
		在具体的使用形式上类似数组，但是由于本质不同，不能代替数组使用。

第18课小结
	数据存储线性表的插入和删除操作存在重大效率隐患
	线性表作为容器类，应该避免拷贝构造和拷贝赋值
	顺序存储线性表可能被当成数组误用
	工程开发中可以考虑使用数组类代替原生数组使用

第19课
19.1 数组类的创建-上
    课程目标
        完成Array类的具体实现
        完成StaticArray类的具体实现
    需求分析
        创建数组类代替原生数组的使用
            数组类包含长度信息
            数组类能够主动发现越界访问

    Array设计要点
        抽象类模板，存储空间的位置和大小由子类完成
        重载数组操作符，判断访问下标是否合法
        提供数组长度的抽象访问函数
        提供数组对象间的复制操作

    StaticArray设计要点
        类模板
            封装原生数组
            使用类模板参数决定数组大小
            实现函数返回数组长度
            拷贝构造和赋值操作

第20课
20.1 数组类的创建-下
    课程目标
        完成DynamicArray设计
    DynamicArray设计要点
        类模板
            动态确定内部数组空间的大小
            实现函数返回数组长度
            拷贝构造和赋值操作

第20课小结
    StaticArray通过封装原声数组的方式实现数组类
    DynamicArray动态申请堆空间，使得数组长度动态可变
    数组对象能够代替原生数组，并且使用上更安全
    代码优化是项目开发中不可或缺的环节
            
第21课
21.1 线性表的链式存储结构
    顺序存储结构线性表的最大问题是：插入和删除需要移动大量的元素！！如何解决？

    链式存储的定义
        为了表示每个数据元素与其直接后继元素之间的逻辑关系，数组元素除了存储本身的信息外，
        还需要存储其直接后继的信息。
    链式存储逻辑结构
        基于链式存储结构的线性表中，每个节点都包含数据域和指针域
            数据域：存储数据元素本身
            指针域：存储相邻节点的地址

    专业术语的统一
        顺序表
            基于顺序存储结构的线性表
        链表
            基于链式存储结构的线性表
                单链表：每个节点只包含直接后继的地址信息
                循环链表：单链表中的最后一个节点的直接后继为第一个节点
                双向链表：单链表中的节点包含直接前驱和后继的地址信息

    链表中的基本概念
        头结点
            链表中的辅助节点，包含指向第一个数据元素的指针
        数据节点
            链表中代表数据元素的节点，表现形式为：(数据元素，地址)
        尾节点
            链表中的最后一个数据节点，包含的地址信息为空
    
    单链表中的内部结构
        头结点在单链表中的意义是：辅助数据元素的定位，方便插入和删除操作；
        因此，头结点不存储实际的数据元素。
第21课小结 
    链表中的数据元素在物理内存中无相邻关系
    链表中的节点都包含数据域和指针域
    头结点用于辅助数据元素的定位，方便插入和删除操作
    插入和删除操作需要保证链表的完整性

第22课
22.1 单链表的具体实现
    课程目标
        完成链式存储结构线性表的实现

    LinkList设计要点
        类模板，通过头结点访问后继节点
        定义内部节点类型Node，用于描述数据域和指针域
        实现线性表的关键操作（增，删，查等）

第22课小结
    通过类模板实现链表，包含头结点和长度成员
    定义节点类型，并通过堆中的节点对象构成链式存储
    为了避免构造错误的隐患，头结点类型需要重定义
    代码优化时编码完成后必不可少的环节

第23课
23.1 顺序表和单链表的对比分析
    遗失的操作 - find
        可以为线性表(List)增加一个查找操作
        int find(const T& e) const
            参数：待查找的数据元素
            返回值：
                >= 0: 数据元素在线性表中第一次出现的位置
                -1 ： 数据元素不存在

    效率的深度分析
        实际工程开发中，时间复杂度只是效率的一个参考指标
            对于内置基础类型(char,int等)，顺序表和单链表的效率不相上下
            对于自定义类型，顺序表在效率上低于单链表

        插入和删除
            顺序表：涉及大量数据对象的复制操作
            单链表：只涉及指针操作，效率与数据对象无关
        数据访问
            顺序表：随机访问，可直接定位数据对象
            单链表：顺序访问，必须从头访问数据对象，无法直接定位

    工程开发中的选择
        顺序表：
            数据元素的类型相对简单，不涉及深拷贝
            数据元素相对稳定，访问操作远多于插入和删除操作
        单链表
            数据元素的类型相对复杂，复制操作相对耗时
            数据元素不稳定，需要经常插入和删除，访问操作较少

第23课小结
    线性表中元素的查找依赖于相等比较操作符==
    顺序表适用于访问需求量较大的场合（随机访问）
    单链表适用于数据元素频繁插入和删除的场合（顺序访问）
    当数据类型相对简单时，顺序表和单链表的效率不相上下

第24课 单链表的遍历与优化
    遗憾的事实
        不能以线性的时间复杂度完成单链表的遍历
    新的需求
        为单链表提供新的方法，在线性时间内完成遍历

    设计思路 -- 游标
        在单链表的内部定义一个游标(Node* m_current)
        遍历开始前将游标位置指向位置为0的数据元素
        获取游标指向的数据元素
        通过节点中的next指针移动游标

    单链表内部的一次封装
        virtual Node* create() { return new Node(); }
        virtual void  destory(Node* pn) { delete pn; }\
    封装的意义???

第24课小结
    单链表的遍历需要在线性时间内完成
    在单链表内部定义游标变量，通过游标变量提高效率
    遍历相关的成员函数是相互依赖，相互配合的关系
    封装节点的申请和删除操作更有利于增强扩展性

第25课 静态单链表的实现
    单链表的一个缺陷
        触发条件
            长时间使用单链表对象骗饭增加和删除数据元素
        可能的结果
            堆空间产生大量的内存碎片，导致系统运行缓慢

    新的线性表
        设计思路
            在单链表的内部增加一片预留的空间，所有的Node对象都在
            这片内存中动态创建和动态销毁
        
        顺序表 + 单链表 = 静态单链表

    静态单链表的实现思路
        通过模板定义静态单链表类（StaticLinkList）
        在类中定义固定大小的空间
        重写create和destroy函数，改变内存的分配和归还方式
        在Node类中重载operator new，用于在指定内存上创建对象

    LinkList中封装create和destroy函数的意义是什么？
        为静态单链表（StaticLinkList）的实现做准备。StaticLinkList与
        LinkList的不同仅在于链表节点内存分配上的不同；因此，将仅有的不同
        封装于父类和子类的虚函数中。

第25课小结
    顺序表与单链表相结合后衍生出静态单链表
    静态单链表是LinkList的子类，拥有单链表的所有操作
    静态单链表在预留的空间中创建节点对象
    静态单链表适合于频繁增删数据元素的场合（最大元素个数固定）

第26课 软件优化

第27课 再论智能指针-上
第28课 再论智能指针-下
    课程目标
        完成SharedPointer类的具体实现
    设计要点
        类模板
            通过计数机制（ref）标识堆内存
                堆内存被指向时：ref++
                指针被置空时：ref--
                ref == 0时：释放堆内存

    智能指针的比较
        由于SharedPointer支持多个对象同时指向一片堆空间，
        因此，必须支持比较操作

    智能指针的使用军规
        只能用来指向堆空间中的单个变量（对象）
        不同类型的智能指针对象不能混合使用
        不要使用delete释放智能指针指向的堆空间

第28课小结
    SharePointer最大程度的模拟了原生指针的行为
    计数机制确保多个智能指针合法的指向同一片堆空间
    智能指针只能用于指向堆空间中的内存
    不同类型的智能指针不要混合使用
    堆对象的生命周期由智能指针进行管理

第29课 循环链表的实现
    什么时循环链表？
        概念上
            任意数据元素都有一个前驱和一个后继
            所有的数据元素的关系构成一个逻辑上的环
        实现上
            循环链表是一种特殊的单链表
            尾结点的指针域保存了首节点的地址

    循环链表的实现思路
        通过模板定义CircleList，继承自LinkList类
        定义内部函数last_to_first()，用于将单链表首尾相连
        特殊处理：首元素的插入操作和删除操作
        重新实现：清空操作和遍历操作
    循环链表的实现要点
        插入位置为0时：
            头结点和尾结点均指向新节点
            新节点成为首节点插入链表
        删除位置为0时：
            头结点和尾结点指向位置为1的结点
            安全销毁首结点

    循环链表的应用
        约瑟夫环问题
            已知n个人(已编号0, 1, 2, 3, ... , n-1分别表示)围坐在一张圆桌周围。从编号
            为s的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人
            又出列；依此规律重复下去，直到圆桌周围的人全部出列。
第29课小结
    循环链表是一种特殊的单链表
    尾结点的指针域保存了首结点的地址
    特殊处理首元素的插入操作和删除操作
    重新实现清空操作和遍历操作

第30课 双向链表的实现
    单链表的另一个缺陷
        单向性
            只能从头结点开始高效访问；链表中的数据元素
        缺陷
            如果需要逆向访问单链表中的数据元素将及其低效

    新的线性表
        设计思路
            在单链表的节点中增加一个指针pre,用于指向当前结点的前驱结点。

第30课小结
    双向链表是为了弥补单链表的缺陷而重新设计的
    在概念上，双向链表不是单链表，没有继承关系
    双向链表中的游标能够直接访问当前结点的前驱和后继
    双向链表是线性表概念的最终实现(更贴近理论上的线性表)
    实现双向链表的子类：DualStaticLinkList和DualCirleList

第31课 老生常谈的两个宏
    Linux内核中常用的两个宏定义
    #ifndef offsetof
    #define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE*)0)->MEMBER)
    #endif

    #ifndef container_of
    #define container_of(ptr, type, member) ({                     \
            const typeof(((type*)0)->member)* __mptr = (ptr);      \    //类型检查
            (type*)((char*)__mptr - offsetof(type, member));})
    #endif

    offsetof用于计算TYPE结构体中MEMBER成员的偏移位置
        编译器清楚的知道结构体成员变量的偏移位置
        通过结构体变量首地址与偏移量定位成员变量

    container_of
        ({ })是GNU C编译器的语法扩展
        ({ })与逗号表达式类似，结果为最后一个语句的值

        typeof是GNU C编译器的特有关键字
        typeof只在编译期生效，用于得到变量的类型

第32课 Linux内核链表分析
    课程目标
        移植Linux内核链表，使其适用于非GNU编译器
        分析Linux内核中链表的基本实现

    移植时的注意事项
        清楚文件间的依赖
            剥离依赖文件中与链表实现相关的代码
        清除平台相关代码（ GNU C ）
            ({})
            typeof
            __builtin_prefetch
            static inline

    Linux内核链表的实现
        带头结点的双向循环链表，且头结点为表中成员
        头结点的 next 指针指向首节点
        头结点的 prev 指针指向尾结点

第32课小结
    Linux内核链表移植时需要剔除依赖以及平台相关代码
    Linux内核链表是带头结点的双向循环链表
    使用Linux内核链表时需要自定义链表结点
        将 struct list_head 作为结点结构体的第一个成员或最后一个成员
        struct list_head 作为最后一个成员时，需要使用 list_entry 宏
        list_entry 的定义中使用了 container_of 宏

第33课 双向循环链表的实现
    DTLib中双向循环链表的设计思路
        数据节点之间在逻辑上构成双向循环链表，头结点仅用于结点的定位。

    实现思路
        通过模板定义DualCircleList类，继承自DualLinkList类
        在DualCircleList内部使用Linux内核链表进行实现
        使用struct list_head 定义 DualCircleList 的头结点
        特殊处理：循环遍历时忽略头结点

    实现要点
        通过list_head进行目标结点定位（ position(i) ）
        通过 list_entry 将 list_head 指针转换为目标结点指针
        通过 list_for_each 实现int find(const T& e) 函数
        遍历函数中的 next() 和 pre() 需要考虑跳过头结点