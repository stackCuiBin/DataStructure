第1课
1.1，起航，新的目标
    数据结构课程的意义
        培养专业的程序设计思维
        训练使用程序语言描述解决方案的能力
        计算机专业的基础课程
        算法分析专业课的先修课程

    课程目标
        创建可复用的数据结构软件库
        分析并优化C++课程中创建的实用类
    使用的技术
        C++面向对象技术
        C++模板技术
        C++异常处理技术

1.2，理解程序的本质
    程序评鉴初探
        用尽量少的时间解决问题
        用尽量少的步骤解决问题
        用尽量少的内存解决问题
    优秀的开发者追求高质量的代码

    数据结构课程的研究范围
        非数值计算类型的程序问题
        数据间的组织和操作方式
        数据的逻辑结构和存储结构

第1课小结
    程序是为了解决实际问题而存在的
    针对同一个问题可以有多种解决方案
    专业程序员应该尽量追求高质量的程序
    数据结构课程主要研究非数值计算问题

第2课
2.1，数据的艺术
    数据的概念
        程序的操作对象，用于描述客观事物
    数据的特点
        可以输入到计算机
        可以被计算机程序处理
    数据的新概念
        数据元素
            组成数据的基本单位
        数据项
            一个数据元素由若干数据项组成
        数据对象
            性质相同的数据元素的集合

    数据结构指数据对象中数据元素之间的关系
        数据元素之间不是独立的
            存在特定的关系，这些关系即结构
        如：
            数据中各个元素之间存在固定的线性关系

    逻辑结构包括：
        集合结构
            数据元素之间没有特别的关系，仅同属相同集合
        线性结构
            数据元素之间是一对一的关系
        树形结构
            数据元素之间存在一对多的层次关系
        图形结构
            数据元素之间是多对多的关系

    物理结构：
        逻辑结构在计算机中的存储形式
            顺序存储结构
                将数据存储在地址连续的存储单元里
            链式存储结构
                将数据存储在任意的存储单元里
                通过保存地址的方式找到相关联的数据元素

第2课小结
    数据结构是相互之间存在特定关系的数据元素的集合
    数据结构可以分为逻辑结构和物理结构

第3课
3.1， 初识程序的灵魂
    数据结构静态的描述了数据元素之间的关系
    高效的程序需要子啊数据结构的技术上设计和选择算法
                        恰当的数据结构
        搞笑的程序-->
                        合适的算法
    
    算法是特定问题求解步骤的描述
    在计算机中表现为指令的有限序列
        算法是独立存在的一种解决问题的方法和思想
        对于算法而言，语言并不重要，重要的是思想

    算法的特性
        输入：算法具有0个或多个输入
        输出：算法至少有1个或多个输出
        有穷性：算法在有限的步骤之后会自动结束而不会无限循环
        确定型：算法中的每一步都有确定的含义，不会出现二义性
        可行性：算法的每一步都是可行的
        正确性：算法对于合法数据能够得到满足要求的结果
                算法能够处理非法输入，并得到合理的结果
                算法对于边界数据和压力数据都得到满足要求的结果
                注意：正确性时算法最需要满足的基本的准则，但是作为
                      计算机程序，不可能无限制的满足这条准则。
        可读性：算法要方便阅读，理解和交流
        健壮性：算法不应该产莫明奇妙的结果
        性价比：利用最少的资源得到满足要求的结果

第3课小结
    算法为了解决实际问题而存在
    数据结构是算法处理问题的载体
    数据结构与算法相辅相成，共同解决问题

第4课
4.1，程序灵魂的审判
    如果两个算法都满足功能性需求，工程中最关心的其他特性是是什么？如何比较评判呢？
    注意：
        性价比(效率)是工程中最关注的算法附加特性！！！
    事后统计法
        比较两个不同算法对同一组数据的运行处理时间
        缺陷
            为了获得不同算法的运行时间必须编写相应程序
            运行时间严重依赖硬件以及运行时的环境因素
            算法的测试数据的选取相当困难
    事前分析估算
        依据统计的方法对算法效率进行估算
        影响算法效率的主要因素
            算法采用的策略和方法
            问题的输入规模
            编译器所产生的代码
            计算机执行速度

    判断一个算法效率时，操作数量中的常数项和其它次要项常常可以
    忽略，只需要关注最高阶项就能得出结论

第4课小结
    算法的度量有事后统计法和事前分析估算法
    事后统计法不容易准确度量算法的效率
    事前分析估算法通过操作数量度量算法效率
    判断一个算法效率时，只需要关注最高阶项就能得出结论

第5课
5.1，算法的时间复杂度
    算法的复杂度
        时间复杂度
            算法运行后对时间需求量的定性描述
        空间复杂度
            算法运行后付空间需求量的定性描述
    注意：
        数据结构课程重点关注的是算法的效率问题，因此，整个课程会集中于讨论算法的时间复杂度；
        但其使用的方法完全可以用于空间复杂度的判断！

    大O表示法
        算法效率严重依赖于操作(Operator)数量
        操作数量的估算可以作为时间复杂度的估算
        在判断时首先关注操作数量的最高次项
            O(5) = O(1)
            O(2n+1) = O(2n) = O(n)

    常见时间复杂度
        1，线性阶时间复杂度：O(n)
        for(int i = 0; i < n; i++)
        {
            // 复杂度为O(1)的程序语句
        }
        循环次数：n

        2，对数阶时间复杂度：O(logn)
        int i = 1;
        while(i < n)
        {
            // 复杂度为O(1)的程序语句
            i *= 2;
        }
        循环次数：log(小2)n

        3，平方阶时间复杂度：O(n*n)
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                // 复杂度为O(1)的程序语句
            }
        }
        循环次数：n*n

第5课小结
    时间复杂度是算法运行时对于时间的需求量
    大O表示法用于描述算法的时间复杂度
    大O表示法只关注操作数量的最高次项
    常见的时间复杂度为：线性阶，平方阶和对数阶

第6课
6.1，算法效率的度量
    常见时间复杂度的比较
        O(1) < O(logn) < O(n*logn) < O(n*n)
              < O(n*n*n)
                 <O(2的n次方) < O(n!) < O(n的n次方)
    当算法的时间复杂度为最后三种时，即使n的值很小，
    实际的程序运行时间也是不可接受的。
    实际使用的算法时间复杂度应该在第一行中。

    算法的最好情况与最坏情况
    意义：
        当算法在最坏情况下仍然能满足需求时，可以推断，
        算法的最好情况和平均情况都满足需求。

    算法的空间复杂度
    定义：S(n) = S(f(n))
        n为算法的问题规模
        f(n)为空间使用函数，与n相关
    推导时间复杂度的方法同样适用于空间复杂度
    
    空间与时间的策略
        多数情况下，算法的时间复杂度更令人关注
        如果有必要，可以通过增加额外空间降低时间复杂度
        同理，也可以通过增加算法的耗时降低空间复杂度

第6课小结
    一般而言，工程中使用的算法，时间复杂度不超过O(n*n*n)
    算法分析与设计时，重点考虑最坏情况下的时间复杂度
    数据结构课程中重点关注算法的时间复杂度
    大O表示法同样适用于算法的空间复杂度
    空间换时间是工程开发中常用的策略

第7课
7.1，课程答疑
    数据结构课程该如何学习？
        1，先从概念上形象的理解数据元素之间的关系
        2，思考这种关系能够解决什么问题
        3，考虑基于这种关系能够产生那些算法
        4，理解和熟悉最终的算法
        5，选择一种熟悉的语言，编码实战

    学习操作系统内核需要用到数据结构吗？
        内存管理
            需要设计页映射表相关的数据结构和访问算法
        进程管理
            需要设计表示进程的数据结构(PCB)和资源分配算法
        线程管理
            需要设计表示线程的数据结构(TCB)和调度算法
        。。。

第8课
8.1，泛型编程简介
    数据结构课程的特点
        专注于数据元素之间的关系
        专注与特定结构之上的算法
    数据结构课程并不关注数据元素的具体类型！

    泛型编程的概念
        不考虑具体数据类型的编程方式

    C++中的函数模板
        一种特殊的函数可用不同类型进行调用
        看起来和普通函数很相似，区别是类型可被参数化

    C++中的类模板
        以相同的方式处理不同的类型
        在类声明前使用template进行标识
        < typename T >用于说明类中使用的泛指类型T
    类模板的应用
        只能显示指定具体类型，无法自动推导
        使用具体类型<Type>定义对象

第8课小结
    模板是泛型编程理论在C++中的实现
    函数模板支持参数的自动推导和显示指定
    类模板在使用时只能显示指定类型
    类模板非常适用于编写数据结构相关的代码

第9课
9.1，智能指针示例
    内存泄露
        动态申请堆空间，用完后不归还
        C++语言中没有垃圾回收机制
        指针无法控制所指堆空间的生命周期
    当代C++软件平台中的智能指针
        指针生命周期结束时主动释放堆空间
        一片堆空间最多只能由一个指针标识
        杜绝指针运算和指针比较
    智能指针的设计方案
        通过类模板描述指针的行为
            能够定义不同类型的指针对象
        重载指针特征操作符(-> 和 *)
            利用对象模拟原生指针的行为

    智能指针的使用军规
        只能用来指向堆空间中的单个对象或者变量

第9课小结
    指针特征操作符(-> 和 *)可以被重载
    重载指针特征操作符能够使用对象代替指针
    智能指针只能用于指向堆空间中的内存
    智能指针的意义在于最大程度的避免内存泄漏问题

第10课
10.1，C++异常简介
    参考C++课程异常讲解

第11课
11.1，异常类构建
    异常的类型可以是自定义类类型
    对于类类型异常的匹配依旧是至上而下严格匹配
    赋值兼容性原则在异常匹配中依然适用
    一般而言
        匹配子类异常的catch放在上部
        匹配父类异常的catch放在下部

    现代C++库必然包含充要的异常类族
    异常类族是数据结构类所依赖的基础设施
    Exception主要包括
        ArithmeticException         计算异常
        IndexOutOfBoundsException   越界异常
        NoEnoughMemoryException     内存不足异常
        NullPointerException        空指针异常
        InvalidParameterException   参数错误异常

    设计原则
        在可复用代码库设计时，尽量使用面向对象技术进行架构，尽量使用异常处理机制
        分离正常逻辑和异常逻辑。

第11课小结
    现代C++库必然包含充要的异常类族
    所有库中的数据结构类都依赖于异常机制
    异常机制能够分离库中代码的正常逻辑和异常逻辑

第12课
12.1，顶层父类创建
    当代软件架构实践中的经验
        尽量使用单重继承的方式进行系统设计
        尽量保持系统中只存在单一的继承树
        尽量使用组合关系代替继承关系

    不幸的事实
        C++语言的灵活性使得代码中可以存在多个继承树
        C++编译器的差异使得同样的代码可能表现不同的行为

    创建DTLib::Object类的意义
        遵循经典设计准则，所有数据结构都继承自Object类
        定义动态内存申请的行为，提高代码的移植性

第12课小结
    Object类是DTLib中数据结构类的顶层父类
    Object类用于统一动态内存申请的行为
    在堆中创建Object子类的对象，失败时返回NULL值
    Object类为纯虚父类，所有子类都能进行动态类型识别

第13课
13.1，类族结构的进化
    遵循经典设计准则
        DTLib中的所有类位于单一的继承树

    改进的关键点
        Exception类继承自Object类
            堆空间中创建异常对象失败时，返回NULL指针
        新增InvalidOperatorException异常类
            成员函数调用时，如果状态不正确则抛出异常
        SmartPointer类继承自Object类
            堆空间中创建智能指针对象失败时，返回NULL指针

    DTLib的开发方式和注意事项
        迭代开发
            每次完成一个小的目标，持续开发，最终打造可复用类库
        单一继承树
            所有类都继承自Object，规范堆对象创建时的行为
        只抛异常，不处理异常
            使用THROW_EXCEPTION抛出异常，提高可移植性
        弱耦合性
            尽量不使用标准库中的类和函数，提高可移植性

第一阶段学习总结
	数据结构与算法之间的关系
	算法效率的度量方法
	DTLib的基础设施建设
		顶层父类
		智能指针
		异常类

第14课
14.1，线性表的本质和操作
	线性表(List)的表现形式
		零个或者多个数据元素组成的集合
		数据元素在位置上是有序排列的
		数据元素的个数是有限的
		数据元素的类型必须相同

	线性表的抽象定义
		线性表是具有相同类型的n(>=0)个数据元素的有限序列

	线性表(List)的性质
		a0为线性表的第一个元素，只有一个后继
		an-1 为线性表的最后一个元素，只有一个前驱
		除a0和an-1外的其他元素ai，既有前驱，又有后继
		直接支持逐项访问和顺序存取

	线性表的一些常用操作
		将元素插入线性表
		将元素从线性表中删除
		获取目标位置处元素的值
		设置目标位置处的元素的值
		获取线性表的长度
		清空线性表

第14课小结
	线性表是数据元素的有序并且有限的集合
	线性表中的数据元素必须是类型相同的
	线性表可用于描述排队关系的问题
	线性表在程序中表现为一种特殊的数据类型
	线性表在C++中表现为一个抽象类

第15课
15.1，线性表的顺序存储结构
	顺序存储的定义
		线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储
		线性表中的数据元素

	顺序存储结构的元素插入操作
		判断目标位置是否合法
		将目标位置之后的所有元素后移一个位置
		将新元素插入目标位置
		线性表长度加1

	顺序存储结构的元素删除操作
		判断目标位置是否合法
		将目标位置的所有元素前移一个位置
		线性表长度减1

第16课
16.1，顺序存储结构的抽象实现
	SeqList设计要点
		抽象类模板，存储空间的位置和大小由子类完成
		实现顺序存储结构线性表的关键操作(增，删，查，等)
		提供数组操作符，方便快速获取元素

第17课
17.1，StaticList和DynamicList
	StaticList设计要点
		类模板
			使用原生数组作为顺序存储空间
			使用模板参数决定数组大小

	DynamicList设计要点
		类模板
			申请连续堆空间作为顺序存储空间
			动态设置顺序存储空间的大小
			保证重置顺序存储空间时的异常安全性
		函数异常安全的概念
			不泄露任何资源
			不允许破坏数据
		函数异常安全的基本保证
			如果异常被抛出
				对象内的任何成员仍然保持有效状态
				没有数据的破坏及资源泄露

第17课小结
	StaticList通过模板参数定义顺序存储空间
	DynamicList通过内存申请定义顺序存储空间
	DynamicList支持动态重置顺序存储空间大小
	DynamicList中的resize()函数实现保证异常安全

第18课
18.1，顺序存储线性表的分析
	分析
		对于容器类型的类，可以考虑禁用拷贝构造和赋值操作
		template < typename T >
		class List : public Object
		{
		protected:
			List(const List&);
			List& operator=(const List&);
		public:
			List() {}
			// ...
		};

	问题分析
		顺序存储结构线性表提供了数组操作符重载，通过重载能够快捷方便的获取目标位置处的数据元素，
		在具体的使用形式上类似数组，但是由于本质不同，不能代替数组使用。

第18课小结
	数据存储线性表的插入和删除操作存在重大效率隐患
	线性表作为容器类，应该避免拷贝构造和拷贝赋值
	顺序存储线性表可能被当成数组误用
	工程开发中可以考虑使用数组类代替原生数组使用

第19课
19.1 数组类的创建-上
    课程目标
        完成Array类的具体实现
        完成StaticArray类的具体实现
    需求分析
        创建数组类代替原生数组的使用
            数组类包含长度信息
            数组类能够主动发现越界访问

    Array设计要点
        抽象类模板，存储空间的位置和大小由子类完成
        重载数组操作符，判断访问下标是否合法
        提供数组长度的抽象访问函数
        提供数组对象间的复制操作

    StaticArray设计要点
        类模板
            封装原生数组
            使用类模板参数决定数组大小
            实现函数返回数组长度
            拷贝构造和赋值操作

第20课
20.1 数组类的创建-下
    课程目标
        完成DynamicArray设计
    DynamicArray设计要点
        类模板
            动态确定内部数组空间的大小
            实现函数返回数组长度
            拷贝构造和赋值操作

第20课小结
    StaticArray通过封装原声数组的方式实现数组类
    DynamicArray动态申请堆空间，使得数组长度动态可变
    数组对象能够代替原生数组，并且使用上更安全
    代码优化是项目开发中不可或缺的环节
            
第21课
21.1 线性表的链式存储结构
    顺序存储结构线性表的最大问题是：插入和删除需要移动大量的元素！！如何解决？

    链式存储的定义
        为了表示每个数据元素与其直接后继元素之间的逻辑关系，数组元素除了存储本身的信息外，
        还需要存储其直接后继的信息。
    链式存储逻辑结构
        基于链式存储结构的线性表中，每个节点都包含数据域和指针域
            数据域：存储数据元素本身
            指针域：存储相邻节点的地址

    专业术语的统一
        顺序表
            基于顺序存储结构的线性表
        链表
            基于链式存储结构的线性表
                单链表：每个节点只包含直接后继的地址信息
                循环链表：单链表中的最后一个节点的直接后继为第一个节点
                双向链表：单链表中的节点包含直接前驱和后继的地址信息

    链表中的基本概念
        头结点
            链表中的辅助节点，包含指向第一个数据元素的指针
        数据节点
            链表中代表数据元素的节点，表现形式为：(数据元素，地址)
        尾节点
            链表中的最后一个数据节点，包含的地址信息为空
    
    单链表中的内部结构
        头结点在单链表中的意义是：辅助数据元素的定位，方便插入和删除操作；
        因此，头结点不存储实际的数据元素。
第21课小结 
    链表中的数据元素在物理内存中无相邻关系
    链表中的节点都包含数据域和指针域
    头结点用于辅助数据元素的定位，方便插入和删除操作
    插入和删除操作需要保证链表的完整性

第22课
22.1 单链表的具体实现
    课程目标
        完成链式存储结构线性表的实现

    LinkList设计要点
        类模板，通过头结点访问后继节点
        定义内部节点类型Node，用于描述数据域和指针域
        实现线性表的关键操作（增，删，查等）

第22课小结
    通过类模板实现链表，包含头结点和长度成员
    定义节点类型，并通过堆中的节点对象构成链式存储
    为了避免构造错误的隐患，头结点类型需要重定义
    代码优化时编码完成后必不可少的环节

第23课
23.1 顺序表和单链表的对比分析
    遗失的操作 - find
        可以为线性表(List)增加一个查找操作
        int find(const T& e) const
            参数：待查找的数据元素
            返回值：
                >= 0: 数据元素在线性表中第一次出现的位置
                -1 ： 数据元素不存在

    效率的深度分析
        实际工程开发中，时间复杂度只是效率的一个参考指标
            对于内置基础类型(char,int等)，顺序表和单链表的效率不相上下
            对于自定义类型，顺序表在效率上低于单链表

        插入和删除
            顺序表：涉及大量数据对象的复制操作
            单链表：只涉及指针操作，效率与数据对象无关
        数据访问
            顺序表：随机访问，可直接定位数据对象
            单链表：顺序访问，必须从头访问数据对象，无法直接定位

    工程开发中的选择
        顺序表：
            数据元素的类型相对简单，不涉及深拷贝
            数据元素相对稳定，访问操作远多于插入和删除操作
        单链表
            数据元素的类型相对复杂，复制操作相对耗时
            数据元素不稳定，需要经常插入和删除，访问操作较少

第23课小结
    线性表中元素的查找依赖于相等比较操作符==
    顺序表适用于访问需求量较大的场合（随机访问）
    单链表适用于数据元素频繁插入和删除的场合（顺序访问）
    当数据类型相对简单时，顺序表和单链表的效率不相上下

第24课 单链表的遍历与优化
    遗憾的事实
        不能以线性的时间复杂度完成单链表的遍历
    新的需求
        为单链表提供新的方法，在线性时间内完成遍历

    设计思路 -- 游标
        在单链表的内部定义一个游标(Node* m_current)
        遍历开始前将游标位置指向位置为0的数据元素
        获取游标指向的数据元素
        通过节点中的next指针移动游标

    单链表内部的一次封装
        virtual Node* create() { return new Node(); }
        virtual void  destory(Node* pn) { delete pn; }\
    封装的意义???

第24课小结
    单链表的遍历需要在线性时间内完成
    在单链表内部定义游标变量，通过游标变量提高效率
    遍历相关的成员函数是相互依赖，相互配合的关系
    封装节点的申请和删除操作更有利于增强扩展性

第25课 静态单链表的实现
    单链表的一个缺陷
        触发条件
            长时间使用单链表对象骗饭增加和删除数据元素
        可能的结果
            堆空间产生大量的内存碎片，导致系统运行缓慢

    新的线性表
        设计思路
            在单链表的内部增加一片预留的空间，所有的Node对象都在
            这片内存中动态创建和动态销毁
        
        顺序表 + 单链表 = 静态单链表

    静态单链表的实现思路
        通过模板定义静态单链表类（StaticLinkList）
        在类中定义固定大小的空间
        重写create和destroy函数，改变内存的分配和归还方式
        在Node类中重载operator new，用于在指定内存上创建对象

    LinkList中封装create和destroy函数的意义是什么？
        为静态单链表（StaticLinkList）的实现做准备。StaticLinkList与
        LinkList的不同仅在于链表节点内存分配上的不同；因此，将仅有的不同
        封装于父类和子类的虚函数中。

第25课小结
    顺序表与单链表相结合后衍生出静态单链表
    静态单链表是LinkList的子类，拥有单链表的所有操作
    静态单链表在预留的空间中创建节点对象
    静态单链表适合于频繁增删数据元素的场合（最大元素个数固定）

第26课 软件优化

第27课 再论智能指针-上
第28课 再论智能指针-下
    课程目标
        完成SharedPointer类的具体实现
    设计要点
        类模板
            通过计数机制（ref）标识堆内存
                堆内存被指向时：ref++
                指针被置空时：ref--
                ref == 0时：释放堆内存

    智能指针的比较
        由于SharedPointer支持多个对象同时指向一片堆空间，
        因此，必须支持比较操作

    智能指针的使用军规
        只能用来指向堆空间中的单个变量（对象）
        不同类型的智能指针对象不能混合使用
        不要使用delete释放智能指针指向的堆空间

第28课小结
    SharePointer最大程度的模拟了原生指针的行为
    计数机制确保多个智能指针合法的指向同一片堆空间
    智能指针只能用于指向堆空间中的内存
    不同类型的智能指针不要混合使用
    堆对象的生命周期由智能指针进行管理

第29课 循环链表的实现
    什么时循环链表？
        概念上
            任意数据元素都有一个前驱和一个后继
            所有的数据元素的关系构成一个逻辑上的环
        实现上
            循环链表是一种特殊的单链表
            尾结点的指针域保存了首节点的地址

    循环链表的实现思路
        通过模板定义CircleList，继承自LinkList类
        定义内部函数last_to_first()，用于将单链表首尾相连
        特殊处理：首元素的插入操作和删除操作
        重新实现：清空操作和遍历操作
    循环链表的实现要点
        插入位置为0时：
            头结点和尾结点均指向新节点
            新节点成为首节点插入链表
        删除位置为0时：
            头结点和尾结点指向位置为1的结点
            安全销毁首结点

    循环链表的应用
        约瑟夫环问题
            已知n个人(已编号0, 1, 2, 3, ... , n-1分别表示)围坐在一张圆桌周围。从编号
            为s的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人
            又出列；依此规律重复下去，直到圆桌周围的人全部出列。
第29课小结
    循环链表是一种特殊的单链表
    尾结点的指针域保存了首结点的地址
    特殊处理首元素的插入操作和删除操作
    重新实现清空操作和遍历操作

第30课 双向链表的实现
    单链表的另一个缺陷
        单向性
            只能从头结点开始高效访问；链表中的数据元素
        缺陷
            如果需要逆向访问单链表中的数据元素将及其低效

    新的线性表
        设计思路
            在单链表的节点中增加一个指针pre,用于指向当前结点的前驱结点。

第30课小结
    双向链表是为了弥补单链表的缺陷而重新设计的
    在概念上，双向链表不是单链表，没有继承关系
    双向链表中的游标能够直接访问当前结点的前驱和后继
    双向链表是线性表概念的最终实现(更贴近理论上的线性表)
    实现双向链表的子类：DualStaticLinkList和DualCirleList

第31课 老生常谈的两个宏
    Linux内核中常用的两个宏定义
    #ifndef offsetof
    #define offsetof(TYPE, MEMBER)  ((size_t)&((TYPE*)0)->MEMBER)
    #endif

    #ifndef container_of
    #define container_of(ptr, type, member) ({                     \
            const typeof(((type*)0)->member)* __mptr = (ptr);      \    //类型检查
            (type*)((char*)__mptr - offsetof(type, member));})
    #endif

    offsetof用于计算TYPE结构体中MEMBER成员的偏移位置
        编译器清楚的知道结构体成员变量的偏移位置
        通过结构体变量首地址与偏移量定位成员变量

    container_of
        ({ })是GNU C编译器的语法扩展
        ({ })与逗号表达式类似，结果为最后一个语句的值

        typeof是GNU C编译器的特有关键字
        typeof只在编译期生效，用于得到变量的类型

第32课 Linux内核链表分析
    课程目标
        移植Linux内核链表，使其适用于非GNU编译器
        分析Linux内核中链表的基本实现

    移植时的注意事项
        清楚文件间的依赖
            剥离依赖文件中与链表实现相关的代码
        清除平台相关代码（ GNU C ）
            ({})
            typeof
            __builtin_prefetch
            static inline

    Linux内核链表的实现
        带头结点的双向循环链表，且头结点为表中成员
        头结点的 next 指针指向首节点
        头结点的 prev 指针指向尾结点

第32课小结
    Linux内核链表移植时需要剔除依赖以及平台相关代码
    Linux内核链表是带头结点的双向循环链表
    使用Linux内核链表时需要自定义链表结点
        将 struct list_head 作为结点结构体的第一个成员或最后一个成员
        struct list_head 作为最后一个成员时，需要使用 list_entry 宏
        list_entry 的定义中使用了 container_of 宏

第33课 双向循环链表的实现
    DTLib中双向循环链表的设计思路
        数据节点之间在逻辑上构成双向循环链表，头结点仅用于结点的定位。

    实现思路
        通过模板定义DualCircleList类，继承自DualLinkList类
        在DualCircleList内部使用Linux内核链表进行实现
        使用struct list_head 定义 DualCircleList 的头结点
        特殊处理：循环遍历时忽略头结点

    实现要点
        通过list_head进行目标结点定位（ position(i) ）
        通过 list_entry 将 list_head 指针转换为目标结点指针
        通过 list_for_each 实现int find(const T& e) 函数
        遍历函数中的 next() 和 pre() 需要考虑跳过头结点

第34课 栈的概念及实现-上
    栈的定义
        栈是一种特殊的线性表
        栈仅能在线性表的一端进行操作
            栈顶(Top): 允许操作的一端
            栈底(Bottom): 不允许操作的一端

    StaticStack设计要点
        类模板
            使用原生数组作为栈的存储空间
            使用模板参数决定栈的最大容量

第35课 栈的概念及实现-下
    链式栈的设计要点
        类模板，抽象父类 Stack 的直接子类
        在内部组合使用 LinkList 类，实现栈的链式存储
        只在单链表成员对象的内部进行操作

    栈的应用实践
        符号匹配问题
            在C语言中有一些成对匹配出现的符号
                括号：(), [], {}, <>
                引号：'', ""
        如何实现编译器中的符号成对检测？
        算法思路
            从第一个字符开始扫描
                当遇见普通字符时忽略
                当遇见左符号时压入栈中
                当遇见右符号时弹出栈顶符号，并进行匹配
            结束
                成功：所有字符扫描完毕，且栈为空
                失败：匹配失败或所有字符扫描完毕但栈非空

第35课小结
    链式栈的实现组合使用了单链表对象
    在单链表的头部进行操作能够实现高效的入栈和出栈操作
    栈“先进后出”的特性适用于检测成对出现的符号
    栈特别适合于需要“就近匹配”的场合

第36课 队列的概念及实现-上
    队列是一种特殊的线性表
    队列仅能在线性表的两端进行操作
        对头(Front)：取出数据元素的一端
        队尾(Rear)：插入数据元素的一端

    StaticQueue设计要点
        类模板
            使用原生数组作为队列的存储空间
            使用模板参数决定队列的最大容量
    StaticQueue实现要点（循环计数法）
        关键操作
            进队列：m_space[m_rear] = e; m_rear = (m_rear + 1) % N;
            出队列：m_front = (m_front + 1) % N;
        队列状态
            队空：(m_length == 0) && (m_front == m_rear)
            队满：(m_length == N) && (m_front == m_rear)

第37课 队列的概念及实现-下
    链式队列的设计要点
        类模板，抽象父类Queue的直接子类
        在内部使用链式结构实现元素的存储
        只在链表的头部和尾部进行操作

第37课小结
    StaticQueue在初始化时可能多次调用元素类型的构造函数
    LinkList的组合使用能够实现队列的功能，但是不够高效
    LinkQueue的最终实现组合使用了 Linux 内核链表
    LinkQueue中入队和出队操作可以在常量时间内完成

第38课 两个有趣问题
    问题
        栈和队列在实现上非常相似，是否可以用栈实现队列？
    问题分析 
        用栈的“后进先出”实现队列的“先进先出”特性。
    实现思路
        准备两个栈用于实现队列：stack_in和stack_out
            当有新元素入队时：将其压入stack_in
            当需要出队时：
                stack_out.size() == 0
                    将stack_in中的元素逐一弹出并压入stack_out
                    将stack_out的栈顶元素弹出
                stack_out.size() > 0
                    将stack_out的栈顶元素弹出

    问题
        反之，是否可以用队列实现栈？
    问题分析
        本质为，用队列“先进先出”的特性实现栈“先进后出”的特性。
    实现思路
        准备两个队列用于实现栈：queue_1 [in] 和 queue_2 [out]
            当有新元素入栈时：将其加入队列in
            当需要出栈时
                将队列 in 中的 n-1 个元素出队列，并进入队列 out 中
                将队列 in 中的最后一个元素出队列(出栈)
                交换两个队列的角色：queue_1 [out] 和 queue_2 [in]

第38课小结
    栈和队列在实现上非常类似，可以相互转化实现
    两个栈“后进先出”叠加得到“先进先出”的特性
    两个队列“先进先出”相互配合得到“后进先出”的特性
    栈和队列相互转化的学习有助于强化本质的理解

第39课 字符串类的创建-上
    历史遗留问题
        C语言不支持真正意义上的字符串
        C语言用字符数组和一组函数实现字符串操作
        C语言不支持自定义类型，因此无法获得字符串类型

    从C到C++的进化过程引入了自定义类型
    在C++中可以通过类完成字符串类型的定义
    问题
        C++中的原生类型系统是否包含字符串类型？

    实现时的注意事项
        无缝实现 String 对象与 char* 字符串的互操作
        操作符重载函数需要考虑是否支持const版本
        通过C语言中的字符串函数实现 String 的成员函数

第39课小结
    C/C++语言本身不支持字符串类型
    C语言通过字符数组和一组函数支持字符串操作
    C++通过自定义字符串类型支持字符串操作
    字符串类型通过C语言中的字符串函数实现

第40课 字符串类的创建-下
    添加常见功能函数

第41课 KMP子串查找算法
    朴素解法
        挨个比较子串和目标串，发现匹配不上时，将子串相对目标串右移1位。
    朴素解法的一个优化线索
        S -> a b c d e ... '\0'
        P -> a b c z '\0'
        因为， Pa != Pb 且Pb == Sb
        所以， Pa != Sb
        结论，子串P右移1位比较，没有意义。
    发现：
        匹配失败时的右移位数与子串相关，与目标串无关
        移动位数 = 已匹配的字符数 - 对应的部分匹配值
        任意子串都存在一个唯一的部分匹配表
    部分匹配表示例：
        0  1  2  3  4  5  6
        A  B  C  D  A  B  D
        0  0  0  0  1  2  0
    用法：
        BBC ABCDAB ABCDABCDABDE
            ABCDABD
        第7个字符匹配失败 -> 前6位匹配成功 -> 查表PMT[6-1] -> 右移位数等于：6 - PMT[5] = 6 - 2 = 4
    如何求得部分匹配表？？？
        前缀
            除了最后一个字符以外，一个字符串的全部头部组合
        后缀
            除了第一个字符以外，一个字符串的全部尾部组合
        部分匹配值
            前缀和后缀最长共有元素的长度
        示例：
            P -> a  b  c  d
            前缀：a  ab  abc
            后缀：d  cd  bcd
            部分匹配值为：0（前缀和后缀没有交集）

    怎么编程实现部分匹配表？
    实现关键
        PMT[0] = 0 (下标为0的元素匹配值为0)
        从第2个字符（下标为1）开始递推
        假设PMT[n] = PMT[n-1] + 1 (最长共有元素的长度)
        当假设不成立，PMT[n]在PMT[n-1]的基础上减小

    示例：(直接用前辈总结出来的规律)
        ll -> longest length (前缀、后缀，交集元素的最长长度)
        规则：
            （1）当前要求的ll值，通过历史ll值推导
            （2）当可选ll值为0，直接对比收尾元素
        P -> a b a b a x      ll
        0 -> a                0
        1 -> ab               0
        2 -> aba              0+1=1
        3 -> abab             1+1=2
        4 -> ababa            2+1=3
        5 -> ababax  前: abab == b和x不相等, PMT(3)=ll=1 ==> 前:ab == b和x不相等，PMT(1)=ll=0 ==> ll=0
                     后: abax                               后:ax
                     重叠部分的长度就是当前的ll值，即：3；PMT(3)的含义是查找3个字符时的ll值，而3个字符时的ll值
                     对应着下标为2的情形；编程时注意长度与下标的对应关系。

    部分匹配表的使用(KMP算法)
        下标j处匹配失败 => 前j位匹配成功 => PMT[j-1] => 右移位数：j-PMT[j-1]
        S -> BBC ABCDAB ABCDABCDABDE
        P ->     ABCDABD
        因为，S[i] != P[j]
        所以查表，ll = PMT[j-1]
        于是，右移，i的值不变，j的值改变，j = j-(j-ll) = ll = PMT[j-1]

第41课小结
    部分匹配表是提高子串查找效率的关键
    部分匹配表定义为前缀和后缀最长公有元素的长度
    可以用递推的方法产生部分匹配表
    KMP利用部分匹配值与子串移动位数的关系提高查找效率

第42课 KMP算法应用
    添加字符串类功能函数

第43课 递归的思想应用-上
    递归是一种数学上分而自治的思想
        将原问题分解为规模较小的问题进行处理
            分解后的问题与原问题的类型完全相同，但规模较小
            通过小规模问题的解，能够轻易求得原问题的解
        问题的分解是有限的（递归不能无限进行）
            当边界条件不满足时，分解问题（递归继续进行）
            当边界条件满足时，直接求解（递归结束）
    
    递归在程序设计中的应用
        递归函数
            函数体中存在自我调用的函数
            递归函数必须有递归出口（边界条件）
            函数的无限递归将导致程序崩溃

第43课总结
    递归是一种将问题分而自治的思想
    用递归解决问题首先要建立递归的模型
    递归解决必须要有边界条件，否则无解
    不要陷入递归函数的执行细节，学会同归代码描述递归问题

第44课 递归的思想应用-中
    单向链表的转置
        list -> 0 -> 1 -> 2 -> NULL

                          guard = list->next;
                          ret = reverse(list->next);          
                          guard->next = list;                 len(list) >= 2
                          list->next = NULL;
                          return ret;

        reverse(list) =   list                                len(list) == 1

                          NULL                                list == NULL

    单向排序链表的合并
        list1 -> 1 -> 2 -> 3 -> NULL
        list2 -> 2 -> 4 -> 6 -> NULL

                  list2  list1 == NULL
        递归出口：  
                  list1  list2 == NULL

                  list1->value < list2->value ==>
                    list1->next = merge(list1->next, list2);
                    return list1;
        递归分解：
                  list1->value >= list2->value ==>
                    list2-next = merge(list1, list2->next);
                    return list2;

    汉诺塔问题
        将木块借助B柱由A柱移动到C柱
        每次只能移动一个木块
        只能出现小木块在大木块之上
    问题分解
        将n-1个木块借助C由A柱移动到B柱
        将最底层的唯一木块直接移动到C柱
        将n-1个木块借助A由B柱移动到C柱

第45课 递归的思想与应用-下
    函数调用过程回顾
        程序运行后有一个特殊的内存区供函数调用使用
            用于保存函数中的实参，局部变量，临时变量，等
            从起始地址开始往一个方向增长（如：高地址 -> 低地址）
            有一个专用“指针”标识当前已使用的内存的“顶部”

    八皇后问题
        在一个8x8的国际象棋棋盘上，有8个皇后，每个皇后占一格；
        要求皇后见不会出现相互“攻击的现象”（不能有两个皇后处在
        同一行、同一列或同一对角线上）

第45课小结
    程序运行后的栈存储区专供函数调用使用
    站存储区用于保存实参，局部变量，临时变量，等
    利用栈存储区能够方便的实现回溯算法
    八皇后问题是栈回溯的经典应用

第46课 排序的基本概念
    排序的稳定性
        如果在序列中有两个数据元素 i 和 j，他们的关键字ki == kj，且在排序之前，
        对象 i 在 j前面；如果在排序之后，对象 i 仍在 j 的前面，则称这个排序方法
        是稳定的，否则称这个排序方法是不稳定的。

    排序的审判
        时间性能
            关键性能差异体现在比较和交换的数量
        辅助存储空间
            为完成排序操作需要的额外的存储空间
            必要时可以“空间换时间”
        算法的实现复杂性
            过于复杂的排序法可能影响可读性和可维护性

第46课小结
    排序是数据元素从无序到有序的过程
    排序具有稳定性，是选择排序算法的因素之一
    比较和交换是排序的基本操作
    多关键字排序与但关键字排序无本质区别
    排序的时间性能是区分排序算法好坏的主要因素

第47课 选择排序和插入排序
小结
    选择排序每次选择未排序元素中的最小元素
    插入排序每次将第i个元素插入前面i-1个已排元素中
    选择排序是不稳定的排序法，插入排序是稳定的排序方法
    插入排序和插入排序的时间复杂度为 O(n2)

第48课 冒泡排序和希尔排序
    希尔排序的基本思想
        将待排序列划分为若干组，在每一组内进行插入排序，以使整个序列基本有序，
        然后再对整个序列进行插入排序
    希尔排序示例
        例如：将n个数据元素分成d个子序列：
            { R[1], R[1+d], R[1+2d],..., R[1+kd] }
            { R[2], R[3+d], R[2+2d],..., R[2+kd] }
            ...
            { R[d], R[2d], R[3d],..., R[kd], R[(k+1)d] }
        其中，d称为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为1。

第48课小结
    冒泡排序每次从后向前将较小的元素交互到位
    冒泡排序是一种稳定的排序法，其复杂度为 O(n2)
    希尔排序通过分组的方式进行多次插入排序
    希尔排序是一种不稳定的排序法，其复杂度为 O(n3/2)

第49课 归并排序和快速排序
    归并排序的基本思想
        将两个或两个以上的有序序列合并成一个新的有序序列
            有序序列V[0]...V[m]和V[m+1]...V[n-1]
                          \|/
                      V[0]...V[n-1]
        这种归并方法称为2路归并

    快递排序的基本思想
        任取序列中的某个元素作为基准将整个序列划分为左右两个子序列
            左侧子序列中所有元素都小于或等于整个基准元素
            右侧子序列中所有元素都大于基准元素
            基准元素排在这两个子序列中间
        分别对两个子序列重复进行划分，直到所有的数据元素都排在相应位置上为止

第49课小结
    归并排序需要额外的辅助空间才能完成，空间复杂度为O(n)
    归并排序的时间复杂度为O(n*logn)，是一种稳定的排序法
    快速排序通过递归的方式对排序问题进行划分
    快速排序的时间复杂度为O(n*logn)，是一种不稳定的排序法

第50课 排序的工程应用示例
    当待排数据元素为体积庞大的对象时，如何提高排序的效率？

    问题分析
        排序过程中不可避免的需要进行交换操作
        交换操作的本质为数据元素间的相互复制
        当数据元素体积较大时，交换操作耗时巨大
    解决方案：代理模式
        为待排数据元素设置代理对象
        为代理对象所组成的序列进行排序
        需要访问有序数据元素时，通过访问代理序列完成

第50课小结
    DTLib中的排序类和数组类之间存在关联关系
    排序类能够对数据类对象进行排序
    当排序体积庞大的对象时，使用代理模式间接完成
    代理模式的使用有效避开大对象交换时的耗时操作
    代理模式解决方案是空间换时间思想的体现

第51课 树的定义与操作
    树是一种非线性的数据结构
    树是由 n 个节点组成的有限集合
        如果 n = 0，称为空树
        如果 n > 0, 则：
            有一个特定的称之为根(root)的结点
            根结点只有直接后继，但没有直接前驱
            除根以外的其它结点划分为 m(m>0)个互不相交的有限集合T0,T1,...Tm-1，每个集合
            又是一棵树，并且称之为根的子树(sub tree)

    树中度的概念
        树的结点包含一个数据及若干指向子树的分支
        结点拥有的子树数目称为结点的度
            度为 0 的结点称为叶结点
            度不为 0 的结点称为分支结点
        树的度定义为所有结点中度的最大值

    树中的前驱和后继
        结点的直接后继称为该结点的孩子
            相应的，该结点称为孩子的双亲
        结点的孩子的孩子的...称为该结点的子孙
            相应的，该结点称为子孙的祖先
        同一个双亲的孩子之间互称兄弟

    树中结点的层次
        根为第 1 层
        根的孩子为第 2 层
        树中结点的最大层次称为树的深度或高度
    
    树的有序性
        如果树中结点的各子树从左向右是有次序的，子树间不能互换位置，则称该树为有序树，否则为无序树。
        若为有序树，则两者完全不同！

    森林的概念
        森林是由n(n>=0)棵互不相交的树组成的集合

    树的一些常用操作
        插入
        删除
        获取结点数
        获取树的高度
        获取树的度
        清空树中元素
        ...

第51课小结
    树是一种非线性的数据结构
    结点拥有唯一前驱(父结点)和若干后继(子结点)
    树的结点包含一个数据及若干指向其它结点的指针
    树与结点在程序中表现为特殊的数据类型

第52课 树的存储结构与实现
    设计要点
        GTree为通用树结构，每个结点可以存在多个后继结点
        GTreeNode能够包含任意多指向后继结点的指针
        实现树结构的所有操作(增，删，查，等)

    问题
        每个树结点中为什么包含指向前驱结点的指针？
        根结点 -> 叶结点：非线性数据结构
        叶结点 -> 根结点：线性数据结构(链表)

第53课 树中结点的查找操作

第54课 树中结点的插入操作
    问题
        如何确定新结点在树中的位置？
    
    问题分析
        树是非线性的，无法采用下标的形式定位数据元素
        每一个树结点都有唯一的前驱结点(父结点)
        因此，必须先找到前驱结点，才能完成新结点的插入

第54课小结
    插入操作是构建树的唯一操作
    执行插入操作时必须指明结点间的父子关系
    插入操作必须正确处理指向父结点的指针
    插入数据元素时需要从堆空间中创建结点

第55课 树中结点的清除操作
    问题
        树中的结点可能来源于不同的存储空间，如何判断堆空间中的结点并释放？
    问题分析
        单凭内存地址很难准确判断具体的存储区域
        只有堆空间的内存需要主动释放(delete)
        清除操作时只需要对堆空间中的结点进行释放
    解决方案：工厂模式
        在 GTreeNode 中增加成员变量 m_flag
        将 GTreeNode 中的 operator new 重载为保护成员函数
        提供工厂方法 GTreeNode<T>* NewNode()
        在工厂方法中 new 将新结点并将 m_flag 设置为 true

第55课小结
    清除操作作用于销毁树中的每个结点
    销毁结点时需要决定是否释放对应的内存空间
    工厂模式可用于定制堆空间中的结点
    只有销毁定制结点的时候需要进行释放

第56课 树中结点的删除操作
    删除操作成员函数的设计要点
        将被删除结点所代表的子树进行删除
        删除函数返回一颗堆空间中的树
        具体返回值为指向树的智能指针对象

    实用的设计原则
        当需要从函数中返回堆空间中的对象时，使用智能指针(SharePointer)
        作为函数的返回值。

第56课小结
    删除操作将目标结点所代表的子树删除
    删除操作必须完善处理父结点和子结点的关系
    删除操作的返回值为指向树的智能指针对象
    函数中返回堆中的对象时，使用智能指针作为返回值

第57课 树中属性操作的实现

第58课 树形结构的层次遍历
    问题
        如何按层次遍历通用树结构中的每一个数据元素？

    当前的事实
        树是非线性的线性结构，树的结点没有固定的编码方式
    新的需求
        为通用树结构提供新的方法，快速遍历每一个结点
    设计思路(游标)
        在树中定义一个游标
        遍历开始前将游标指向根结点
        获取游标指向的数据元素
        通过结点中的 child 成员移动游标

    层次遍历算法
        原料：class LinkQueue<T>
        游标：LinkQueue<T>::front()
        思想：
            begin()    将根结点压入队列中
            current()  访问队头元素指向的数据元素
            next()     队头元素弹出，将队头元素的孩子压入队列中(核心)
            end()      判断队列是否为空
    
第58课小结
    树的结点没有固定的编码方式
    可以按照层次关系对树中的结点进行遍历
    通过游标的思想设计遍历成员函数
    遍历成员函数是相互依赖，相互配合的关系
    遍历算法的核心为队列的使用

第59课 树到二叉树的转换
    通用树结构的回顾
        双亲孩子表示法
            每个结点都有一个指向其双亲的指针
            每个结点都有若干个指向其孩子的指针

    另一种树结构模型
        孩子兄弟表示法
            每个结点都有一个指向其第一个孩子的指针
            每个结点都有一个指向其第一个右兄弟的指针
        特点
            能够表示任意的树形结构
            每个结点包含一个数据成员和两个指针成员
            孩子结点指针和兄弟结点指针构成了“树叉”

    二叉树的定义
        二叉树是由 n(n>=0) 个结点组成的有限集合，该集合或者为空，或者是由一个根结点
        加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。
    特殊的二叉树
        满二叉树 (Full Binary Tree)
            如果二叉树中所有分支结点的度数都为2，且叶子结点都在同一层次上，则称这类
            二叉树为满二叉树。
        完全二叉树 (Complete Binary Tree)
            如果一棵具有 n 个结点的高度为 k 的二叉树，它的每一个结点都与高度为 k 的
            满二叉树中编号为 1——n 的结点一一对应，则称这棵二叉树为完全二叉树。(从上到
            下从左到右编号)

    完全二叉树的特性
        同样结点数的二叉树，完全二叉树的高度最小
        完全二叉树的叶结点仅出现在最下面两层
            最底层的叶节点一定出现子啊左边
            倒数第二层的叶结点一定出现在右边jiedian
            完全二叉树中度为 1 的结点只有左孩子

第60课 二叉树的深层特性
    性质1
        在二叉树的第 i 层最多有 2(i-1)次方 个结点。（i >= 1）
    性质2
        高度为 k 的二叉树最多有 2(k次方)-1 个结点。 (k >= 0)
    性质3
        对任何一棵二叉树，如果其叶结点有 n0 个，度为2的非叶结点有 n2
        个，则有 n0 = n2 + 1
    性质4
        具有 n 个结点的完全二叉树的高度为 |log(小2)n| + 1 。（|x|表示不大于x的最大整数） 
    性质5
        一棵有 n 个结点的二叉树(高度为|log(小2)n|+1)，按层次对结点进行编号(从上到下，从左到右)，
        对任意结点 i 有：
            如果 i = 1, 则结点 i 是二叉树的根
            如果 i > 1, 则其双亲结点为|i/2|
            如果 2i <= n, 则结点 i 的左孩子为 2i
            如果 2i > n, 则结点 i 无孩子
            如果 2i+1 <= n，则结点 i 的右孩子为 2i+1
            如果 2i+1 > n, 则结点 i 无右孩子