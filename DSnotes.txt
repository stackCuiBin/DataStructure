1，起航，新的目标
    数据结构课程的意义
        培养专业的程序设计思维
        训练使用程序语言描述解决方案的能力
        计算机专业的基础课程
        算法分析专业课的先修课程

    课程目标
        创建可复用的数据结构软件库
        分析并优化C++课程中创建的实用类
    使用的技术
        C++面向对象技术
        C++模板技术
        C++异常处理技术
第1课完

2，理解程序的本质
    程序评鉴初探
        用尽量少的时间解决问题
        用尽量少的步骤解决问题
        用尽量少的内存解决问题
    优秀的开发者追求高质量的代码

    数据结构课程的研究范围
        非数值计算类型的程序问题
        数据间的组织和操作方式
        数据的逻辑结构和存储结构

第2课小结
    程序是为了解决实际问题而存在的
    针对同一个问题可以有多种解决方案
    专业程序员应该尽量追求高质量的程序
    数据结构课程主要研究非数值计算问题

3，数据的艺术
    数据的概念
        程序的操作对象，用于描述客观事物
    数据的特点
        可以输入到计算机
        可以被计算机程序处理
    数据的新概念
        数据元素
            组成数据的基本单位
        数据项
            一个数据元素由若干数据项组成
        数据对象
            性质相同的数据元素的集合

    数据结构指数据对象中数据元素之间的关系
        数据元素之间不是独立的
            存在特定的关系，这些关系即结构
        如：
            数据中各个元素之间存在固定的线性关系

    逻辑结构包括：
        集合结构
            数据元素之间没有特别的关系，仅同属相同集合
        线性结构
            数据元素之间是一对一的关系
        树形结构
            数据元素之间存在一对多的层次关系
        图形结构
            数据元素之间是多对多的关系

    物理结构：
        逻辑结构在计算机中的存储形式
            顺序存储结构
                将数据存储在地址连续的存储单元里
            链式存储结构
                将数据存储在任意的存储单元里
                通过保存地址的方式找到相关联的数据元素

第3课小结
    数据结构是相互之间存在特定关系的数据元素的集合
    数据结构可以分为逻辑结构和物理结构

4， 初识程序的灵魂
    数据结构静态的描述了数据元素之间的关系
    高效的程序需要子啊数据结构的技术上设计和选择算法
                        恰当的数据结构
        搞笑的程序-->
                        合适的算法
    
    算法是特定问题求解步骤的描述
    在计算机中表现为指令的有限序列
        算法是独立存在的一种解决问题的方法和思想
        对于算法而言，语言并不重要，重要的是思想

    算法的特性
        输入：算法具有0个或多个输入
        输出：算法至少有1个或多个输出
        有穷性：算法在有限的步骤之后会自动结束而不会无限循环
        确定型：算法中的每一步都有确定的含义，不会出现二义性
        可行性：算法的每一步都是可行的
        正确性：算法对于合法数据能够得到满足要求的结果
                算法能够处理非法输入，并得到合理的结果
                算法对于边界数据和压力数据都得到满足要求的结果
                注意：正确性时算法最需要满足的基本的准则，但是作为
                      计算机程序，不可能无限制的满足这条准则。
        可读性：算法要方便阅读，理解和交流
        健壮性：算法不应该产莫明奇妙的结果
        性价比：利用最少的资源得到满足要求的结果

第4课小结
    算法为了解决实际问题而存在
    数据结构是算法处理问题的载体
    数据结构与算法相辅相成，共同解决问题

5，程序灵魂的审判
    如果两个算法都满足功能性需求，工程中最关心的其他特性是是什么？如何比较评判呢？
    注意：
        性价比(效率)是工程中最关注的算法附加特性！！！
    事后统计法
        比较两个不同算法对同一组数据的运行处理时间
        缺陷
            为了获得不同算法的运行时间必须编写相应程序
            运行时间严重依赖硬件以及运行时的环境因素
            算法的测试数据的选取相当困难
    事前分析估算
        依据统计的方法对算法效率进行估算
        影响算法效率的主要因素
            算法采用的策略和方法
            问题的输入规模
            编译器所产生的代码
            计算机执行速度

    判断一个算法效率时，操作数量中的常数项和其它次要项常常可以
    忽略，只需要关注最高阶项就能得出结论

第5课小结
    算法的度量有事后统计法和事前分析估算法
    事后统计法不容易准确度量算法的效率
    事前分析估算法通过操作数量度量算法效率
    判断一个算法效率时，只需要关注最高阶项就能得出结论

6，算法的时间复杂度
    算法的复杂度
        时间复杂度
            算法运行后对时间需求量的定性描述
        空间复杂度
            算法运行后付空间需求量的定性描述
    注意：
        数据结构课程重点关注的是算法的效率问题，因此，整个课程会集中于讨论算法的时间复杂度；
        但其使用的方法完全可以用于空间复杂度的判断！

    大O表示法
        算法效率严重依赖于操作(Operator)数量
        操作数量的估算可以作为时间复杂度的估算
        在判断时首先关注操作数量的最高次项
            O(5) = O(1)
            O(2n+1) = O(2n) = O(n)

    常见时间复杂度
        1，线性阶时间复杂度：O(n)
        for(int i = 0; i < n; i++)
        {
            // 复杂度为O(1)的程序语句
        }
        循环次数：n

        2，对数阶时间复杂度：O(logn)
        int i = 1;
        while(i < n)
        {
            // 复杂度为O(1)的程序语句
            i *= 2;
        }
        循环次数：log(小2)n

        3，平方阶时间复杂度：O(n*n)
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                // 复杂度为O(1)的程序语句
            }
        }
        循环次数：n*n

第6课小结
    时间复杂度是算法运行时对于时间的需求量
    大O表示法用于描述算法的时间复杂度
    大O表示法只关注操作数量的最高次项
    常见的时间复杂度为：线性阶，平方阶和对数阶

7，算法效率的度量
    常见时间复杂度的比较
        O(1) < O(logn) < O(n*logn) < O(n*n)
              < O(n*n*n)
                 <O(2的n次方) < O(n!) < O(n的n次方)
    当算法的时间复杂度为最后三种时，即使n的值很小，
    实际的程序运行时间也是不可接受的。
    实际使用的算法时间复杂度应该在第一行中。

    算法的最好情况与最坏情况
    意义：
        当算法在最坏情况下仍然能满足需求时，可以推断，
        算法的最好情况和平均情况都满足需求。

    算法的空间复杂度
    定义：S(n) = S(f(n))
        n为算法的问题规模
        f(n)为空间使用函数，与n相关
    推导时间复杂度的方法同样适用于空间复杂度
    
    空间与时间的策略
        多数情况下，算法的时间复杂度更令人关注
        如果有必要，可以通过增加额外空间降低时间复杂度
        同理，也可以通过增加算法的耗时降低空间复杂度

第7课小结
    一般而言，工程中使用的算法，时间复杂度不超过O(n*n*n)
    算法分析与设计时，重点考虑最坏情况下的时间复杂度
    数据结构课程中重点关注算法的时间复杂度
    大O表示法同样适用于算法的空间复杂度
    空间换时间是工程开发中常用的策略

8，课程答疑
    数据结构课程该如何学习？
        1，先从概念上形象的理解数据元素之间的关系
        2，思考这种关系能够解决什么问题
        3，考虑基于这种关系能够产生那些算法
        4，理解和熟悉最终的算法
        5，选择一种熟悉的语言，编码实战

    学习操作系统内核需要用到数据结构吗？
        内存管理
            需要设计页映射表相关的数据结构和访问算法
        进程管理
            需要设计表示进程的数据结构(PCB)和资源分配算法
        线程管理
            需要设计表示线程的数据结构(TCB)和调度算法
        。。。
第8课完

9，泛型编程简介
    数据结构课程的特点
        专注于数据元素之间的关系
        专注与特定结构之上的算法
    数据结构课程并不关注数据元素的具体类型！

    泛型编程的概念
        不考虑具体数据类型的编程方式

    C++中的函数模板
        一种特殊的函数可用不同类型进行调用
        看起来和普通函数很相似，区别是类型可被参数化

    C++中的类模板
        以相同的方式处理不同的类型
        在类声明前使用template进行标识
        < typename T >用于说明类中使用的泛指类型T
    类模板的应用
        只能显示指定具体类型，无法自动推导
        使用具体类型<Type>定义对象

第9课小结
    模板是泛型编程理论在C++中的实现
    函数模板支持参数的自动推导和显示指定
    类模板在使用时只能显示指定类型
    类模板非常适用于编写数据结构相关的代码

10，智能指针示例
    内存泄露
        动态申请堆空间，用完后不归还
        C++语言中没有垃圾回收机制
        指针无法控制所指堆空间的生命周期
    当代C++软件平台中的智能指针
        指针生命周期结束时主动释放堆空间
        一片堆空间最多只能由一个指针标识
        杜绝指针运算和指针比较
    智能指针的设计方案
        通过类模板描述指针的行为
            能够定义不同类型的指针对象
        重载指针特征操作符(-> 和 *)
            利用对象模拟原生指针的行为

    智能指针的使用军规
        只能用来指向堆空间中的单个对象或者变量

第10课小结
    指针特征操作符(-> 和 *)可以被重载
    重载指针特征操作符能够使用对象代替指针
    智能指针只能用于指向堆空间中的内存
    智能指针的意义在于最大程度的避免内存泄漏问题

11，C++异常简介
    参考C++课程异常讲解

第11课完

12，异常类构建
    异常的类型可以是自定义类类型
    对于类类型异常的匹配依旧是至上而下严格匹配
    赋值兼容性原则在异常匹配中依然适用
    一般而言
        匹配子类异常的catch放在上部
        匹配父类异常的catch放在下部

    现代C++库必然包含充要的异常类族
    异常类族是数据结构类所依赖的基础设施
    Exception主要包括
        ArithmeticException         计算异常
        IndexOutOfBoundsException   越界异常
        NoEnoughMemoryException     内存不足异常
        NullPointerException        空指针异常
        InvalidParameterException   参数错误异常

    设计原则
        在可复用代码库设计时，尽量使用面向对象技术进行架构，尽量使用异常处理机制
        分离正常逻辑和异常逻辑。

第12课小结
    现代C++库必然包含充要的异常类族
    所有库中的数据结构类都依赖于异常机制
    异常机制能够分离库中代码的正常逻辑和异常逻辑

13，顶层父类创建
    当代软件架构实践中的经验
        尽量使用单重继承的方式进行系统设计
        尽量保持系统中只存在单一的继承树
        尽量使用组合关系代替继承关系

    不幸的事实
        C++语言的灵活性使得代码中可以存在多个继承树
        C++编译器的差异使得同样的代码可能表现不同的行为

    创建DTLib::Object类的意义
        遵循经典设计准则，所有数据结构都继承自Object类
        定义动态内存申请的行为，提高代码的移植性

第13课小结
    Object类是DTLib中数据结构类的顶层父类
    Object类用于统一动态内存申请的行为
    在堆中创建Object子类的对象，失败时返回NULL值
    Object类为纯虚父类，所有子类都能进行动态类型识别

14，类族结构的进化
    遵循经典设计准则
        DTLib中的所有类位于单一的继承树

    改进的关键点
        Exception类继承自Object类
            堆空间中创建异常对象失败时，返回NULL指针
        新增InvalidOperatorException异常类
            成员函数调用时，如果状态不正确则抛出异常
        SmartPointer类继承自Object类
            堆空间中创建智能指针对象失败时，返回NULL指针

    DTLib的开发方式和注意事项
        迭代开发
            每次完成一个小的目标，持续开发，最终打造可复用类库
        单一继承树
            所有类都继承自Object，规范堆对象创建时的行为
        只抛异常，不处理异常
            使用THROW_EXCEPTION抛出异常，提高可移植性
        弱耦合性
            尽量不使用标准库中的类和函数，提高可移植性

第一阶段学习总结
	数据结构与算法之间的关系
	算法效率的度量方法
	DTLib的基础设施建设
		顶层父类
		智能指针
		异常类
15，线性表的本质和操作
	线性表(List)的表现形式
		零个或者多个数据元素组成的集合
		数据元素在位置上是有序排列的
		数据元素的个数是有限的
		数据元素的类型必须相同

	线性表的抽象定义
		线性表是具有相同类型的n(>=0)个数据元素的有限序列

	线性表(List)的性质
		a0为线性表的第一个元素，只有一个后继
		an-1 为线性表的最后一个元素，只有一个前驱
		除a0和an-1外的其他元素ai，既有前驱，又有后继
		直接支持逐项访问和顺序存取

	线性表的一些常用操作
		将元素插入线性表
		将元素从线性表中删除
		获取目标位置处元素的值
		设置目标位置处的元素的值
		获取线性表的长度
		清空线性表

第15课小结
	线性表是数据元素的有序并且有限的集合
	线性表中的数据元素必须是类型相同的
	线性表可用于描述排队关系的问题
	线性表在程序中表现为一种特殊的数据类型
	线性表在C++中表现为一个抽象类

16，线性表的顺序存储结构
	顺序存储的定义
		线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储
		线性表中的数据元素

	顺序存储结构的元素插入操作
		判断目标位置是否合法
		将目标位置之后的所有元素后移一个位置
		将新元素插入目标位置
		线性表长度加1

	顺序存储结构的元素删除操作
		判断目标位置是否合法
		将目标位置的所有元素前移一个位置
		线性表长度减1
第16课完

17，顺序存储结构的抽象实现
	SeqList设计要点
		抽象类模板，存储空间的位置和大小由子类完成
		实现顺序存储结构线性表的关键操作(增，删，查，等)
		提供数组操作符，方便快速获取元素
第17课完

18，StaticList和DynamicList
	StaticList设计要点
		类模板
			使用原生数组作为顺序存储空间
			使用模板参数决定数组大小

	DynamicList设计要点
		类模板
			申请连续堆空间作为顺序存储空间
			动态设置顺序存储空间的大小
			保证重置顺序存储空间时的异常安全性
		函数异常安全的概念
			不泄露任何资源
			不允许破坏数据
		函数异常安全的基本保证
			如果异常被抛出
				对象内的任何成员仍然保持有效状态
				没有数据的破坏及资源泄露

第18课小结
	StaticList通过模板参数定义顺序存储空间
	DynamicList通过内存申请定义顺序存储空间
	DynamicList支持动态重置顺序存储空间大小
	DynamicList中的resize()函数实现保证异常安全

